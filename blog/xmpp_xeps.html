<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="../css/blog.css" />
		<title>Подборка полезных XEP расширений протокола XMPP</title>
		<!-- Yandex.Metrika counter -->
		<script type="text/javascript">
		(function (d, w, c) {
		    (w[c] = w[c] || []).push(function() {
			try {
			    w.yaCounter38288850 = new Ya.Metrika({
				id:38288850,
				clickmap:true,
				trackLinks:true,
				accurateTrackBounce:true
			    });
			} catch(e) { }
		    });

		    var n = d.getElementsByTagName("script")[0],
			s = d.createElement("script"),
			f = function () { n.parentNode.insertBefore(s, n); };
		    s.type = "text/javascript";
		    s.async = true;
		    s.src = "https://mc.yandex.ru/metrika/watch.js";

		    if (w.opera == "[object Opera]") {
			d.addEventListener("DOMContentLoaded", f, false);
		    } else { f(); }
		})(document, window, "yandex_metrika_callbacks");
		</script>
		<noscript><div><img src="https://mc.yandex.ru/watch/38288850" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
		<!-- /Yandex.Metrika counter -->
	</head>
	
	<body>
		<div class="page">
			<div class="container">
				<div class="header">
					<a href="http://letiko.com/blog/index.html" class="header-element">
						Home
					</a>
				</div>
<div class="published">05 января 2016</div>
<h1>Подборка полезных XEP расширений протокола XMPP</h1>
<hr>

<p>Пишете свой мессенджер?<br />
Посмотрите на эти расширения, это консолидированный опыт реальных разработчиков.<br /><br />
Внимание: Следует понимать что XEP-ы пилятся сообществом и часто недостаточно согласованно, то есть, не учитывая друг друга, что не хорошо. Конечно, XMPP Council должен отвечать за такие проблемы, но, как можно видеть, фактически никто ни за что не отвечает.
</p><br />

<p><a href="http://xmpp.org/extensions/xep-0013.html">XEP-0013</a>
<br />
<b>Flexible Offline Message Retrieval</b><br />
Это решение вопроса о том что должно быть сделано с сообщениями,<br />
отправленными пользователю который не в сети (offline).
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0045.html">XEP-0045</a>
<br />
<b>Multi-User Chat</b><br />
Описывает процесс превращения приватного диалога в конференцию с сохранением контекста.<br />
Есть механизм приглашений.<br /><br />
Негативный опыт с этим расширением.<br />
В первую очередь, это не групповые чаты, это имитация IRC. Всё. На этом можно было бы закончить про 0045.<br />
Но давайте все-таки разберемся, кто виноват и что делать?<br />
<br />
Знаете, как войти в комнату? Послать запрос, чтобы войти в комнату.<br />
Знаете, как создать комнату? Послать запрос, чтобы войти в комнату.<br />
Если её не существует, она создастся. Уникальность имени комнаты сервера решают, кто как хочет. Нравится? Велком ту хелл.<br /><br />
Тот, кто создавал комнату (ну или кто имеет право), задает количество последних сообщений, которые будут отправлены клиенту, который войдет в комнату. Только вошел, а тебе N сообщений с группы прилетело прямо в морду. Самое ужасное, что 0045 не предусматривает хранения оффлайн участников. А пользователь считается вышедшим из комнаты, как только закроет свой клиент. Для того чтоб вернуться потом в эту комнату, вам нужно или запомнить её имя, или воспользоваться <a href="#xep0048">XEP-0048</a>. Представьте себе теперь ситуацию: вас пригласили в групповой чат, вы вошли, поговорили и добавили себе эту комнату в букмарки, да еще и указали, чтоб входить в эту комнату каждый раз при логине автоматически. Знаете, что будет, если эту комнату удалили, пока вы были оффлайн? При логине вы прочитаете букмарки и сделаете «вход в комнату», а как мы знаем, что создание не отличается от подключения, то правильно! Вы создадите новую комнату. Еще? У меня для вас будет. Если комнату не указать как «persistent», она будет удалена, как только последний пользователь закроет клиент или выйдет из нее. Вот такие дела, кто виноват — ясно, теперь вопрос: что делать?
<br /><br />
Решили мы данную проблему так: все комнаты создаются и конфигурируются, как «member-only», и persistent. В нашем клиенте мы отрисовываем в списке участников всех тех, у кого есть право входить в комнату. Как оказалось, Prosody запрещает получать такой список всем участникам по умолчанию, хотя ХЕР говорит об обратном. Обсудили это с разработчиками Prosody, надеюсь, что договорятся и испрявят. Ну а пока у нас собственное изменение в коде Prosody. Также пришлось сделать изменение, чтобы пользователь мог сам себя исключить из этого списка (да, по умолчанию тоже нельзя), что означает его выход из комнаты. Еще написали кастомный модуль для Prosody, следящий за изменением списка пользователей комнаты (room affiliation) и сообщающий об этом всем участникам. Таким нехитрым способом у нас получились конференции «почти как в скайпе». Интересно, что в XMPP сообществе сейчас обсуждается подобная реализация MUC только используя Pub/Sub, что подтвердил мне один из участников рабочей группы.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0047.html">XEP-0047</a>
<br />
<b>In-Band Bytestreams</b><br />
Слать большие объёмы данных по нему — идея плохая<br />
</p><br />


<p id="xep0048"><a href="http://xmpp.org/extensions/xep-0048.html">XEP-0048</a>
<br />
<b>Bookmarks</b><br />
Расширение позволяющее запомнить имя чат-комнаты в которой ты уже был, но вышел.<br />
</p><br />


<p id="xep0059"><a href="http://xmpp.org/extensions/xep-0059.html">XEP-0059</a>
<br />
<b>Result Set Management</b><br />
В нем описаны параметры для получения архива сообщений, упомянута семантика &lt;start&gt;, и &lt;index&gt;, и так далее.<br />
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0065.html">XEP-0065</a>
<br />
<b>SOCKS5 Bytestreams</b><br />
Используется для передачи файлов если обе стороны сидят за Firewall или NAT.
Тут при неверной конфигурации или стараниями Firewall регулярно возникают проблемы с соединением.<br />
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0066.html">XEP-0066</a>
<br />
<b>Out of Band Data</b><br />
Позволяет прислать пользователю сообщение, к которому прикреплена музыка/кино/фотка/что-угодно.<br />
Дальше клиент своими средствами это проигрывает/показывает в чатике.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0085.html">XEP-0085</a>
<b></b><br />
<b>Chat State Notifications</b><br />
Полезная штука, всегда хорошо знать, печатает ли пользователь или нет, просто приятный ХЕР.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0115.html">XEP-0115</a>
<br />
<b>Entity Capabilities</b><br />
Это, конечно, большой плюс. Эта штука позволяет нам узнать, какие из XEP-ов реализованы в клиенте нашего собеседника,<br />
слать ли ему чат стейт нотификейшнс или нет, ну или еще чего там.
строка2
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0136.html">XEP-0136</a>
<br />
<b>Message Archiving</b><br />
Для получения архива сообщений вы можете установить только два параметра единичной выборки:<br />
max - который выставит максимальное количество сообщений,<br />
start - который означает время, начиная с которого извлекать сообщения.<br />
При этом надо указать имя определённого пользователя для которого делаем выборку сообщений.<br /><br />
То есть заранее нужно знать с каким пользователем сообщения вытаскивать. А чтобы узнать с какими пользователями вообще было общение<br />
вам нужно вытащить коллекции (термин самого XMPP, означает диалог с каждым отдельным пользователем, в каждый отдельный день) и как-то из них вычленить уникальных пользователей.<br />
Ну или вытягивать из отдельных коллекций.<br />
<br />
Выборка по max/start отличается от привычной многим выборке по-странично с выставлением offset и limit.<br />
С другой стороны у механизма с offset и limit тоже есть свои проблемы.<br />
Например в мире SQL, offset и limit — это как бы моветон. <a href="http://use-the-index-luke.com/no-offset">Подробности.</a><br />
Парочка offset/limit в используемой нами MongoDB с точки зрения производительности работает ужасно и везде где можно следует использовать max/start.<br />
Если хотите горизонтально расти до миллионов пользователей в онлайне (ну скажем как World of Tanks),<br />
то для производительности start/max лучше. Смотри <a href="#xep0059">XEP-0059</a>.<br /><br />

Через 0136 (или <a href="#xep0313">XEP-0313</a>, который сильно упрощает жизнь) можно синхронизировать историю.<br />
Есть индивидуальные настройки архивирования для сессий.<br />
Есть описание что делать в случае если один из пользователей хочет чтобы его сообщения не сохранялись на сервере,<br />
а второй хочет этого.<br /><br />

Пытался найти связку из сервера с поддержкой 0136, клиента для Android и клиента для Windows, чтобы синхронизировалась история.
Найти не удалось.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0154.html">XEP-0154</a>
<br />
<b>User Profile</b><br />
Альтернатива для распространённой технологии vCard, стоит взглянуть.<br />
Однако стандарт так и не был доработан.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0163.html">XEP-0163</a>
<br />
<b>Personal Eventing Protocol</b><br />
Позволяет клиенту отправлять уведомления всем остальным при изменении своего статуса.<br />
Например можно использовать для аватарок.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0184.html">XEP-0184</a>
<br />
<b>Message Delivery Receipts</b><br />
Данный черновой стандарт это попытка решения важной проблемы XMPP:<br />
нестабильная работа в нестабильной сети — если соединение рвётся,<br />
сообщения могут теряться, как входящие, так и исходящие.<br /><br />

XMPP работает исключительно по TCP и полагается на стабильность соединения,<br />
нет возможности создавать сессии, размазанные по нескольким соединениям,<br />
нет гарантированной доставки сообщений.<br /><br />

Этот стандарт в паре с <a href="#xep0198">XEP-0198</a> позволяет дать пользователю знать,<br />
что сообщение отправлено и что сервер его получил, и позволяет знать, что сообщение доставлено до адресата.<br />
Очень полезно, но, к сожалению, эта информация не попадает в историю переписки реализованную по <a href="#xep0313">XEP-0313</a>.<br />
<br />
К сожалению 0184 никем не поддерживается и не решает проблемы полностью,<br />
так как находится на высоком уровне и распространяется не на все, а только на часть сообщений протокола.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0191.html">XEP-0191</a>
<br />
<b>Blocking Command</b><br />
Позволяет блокировать спаммеров или отдельные контакты при этом не удаляя их из своего списка собеседников.<br />
</p><br />


<p id="xep0198"><a href="http://xmpp.org/extensions/xep-0198.html">XEP-0198</a>
<br />
<b>Stream Management</b><br />
Позволяет преодолевать небольшие сетевые сбои или изменения в низлежащем TCP соединении.<br />
Например, на каждую отправку в сторону сервера он будет отвечать, что он это получил,<br />
таким образом, вы знаете точно, что сообщение было отправлено.<br />
Также позволяет пользоваться протоколом при не стабильном подключении к сети. Например, если вы сидите с телефона и у вас иногда пропадает сеть, то 0198 позволит вам возобновлять подключение, а не делать ре-логин.<br />
Это расширение точно из необходимых.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0237.html">XEP-0237</a>
<br />
<b>Roster Versioning</b><br />
Хоть и заброшенный, но полезен для экономии полосы пропускания при плохих мобильных соединениях.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0280.html">XEP-0280</a>
<br />
<b>Message Carbons</b><br />
Полезная вещь, позволяет синхронизировать сообщения со всеми вашими девайсами.<br />
Доставка сообщений на все подключенные клиенты (чтобы при перескакивании с устройства на устройство история не дробилась).<br />
То есть если вы залогинены на ноутбуке, мобильном и десктопе, то это позволит вам держать переписку синхронизированной.<br />
Сразу доставит сообщения только на все подключенные устройства.
Имеет реализации в серверах и в клиентах.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0307.html">XEP-0307</a>
<br />
<b>Unique Room Names for Multi-User Chat</b><br />
Позволяет сгенерировать уникальное имя конференции.<br />
К сожалению, статус стандарта «отложен до лучших времен» из-за отсутствия реализаций.<br />
В реальной жизни вполне обходится генерацией уникального UUID.
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0308.html">XEP-0308</a>
<br />
<b>Last Message Correction</b><br />
Это просто очень удобно, поправить очепятку в сообщении, которое уже отправлено.<br />
Это классно, все пользуются, всем теперь легче, грамарнаци спокойны.
</p><br />


<p id="xep0313"><a href="http://xmpp.org/extensions/xep-0313.html">XEP-0313</a>
<br />
<b>Message Archive Management</b><br />
Сильно упрощает жизнь если надо синхронизация истории с сервером.<br />
Служит для хранения истории и ее получения.<br />
Пока реализован только в одном сервере и ни в одном клиенте.<br /><br />

Грустное:<br />
<ul>
<li>Вы никогда не узнаете, было ли доставлено какое либо сообщение, если закрыли клиент.</li>
<li>Для получения истории надо указать от какой даты хочешь и какой лимит что не очень удобно.</li>
<li>Нельзя организовать поиск сообщений по тексту на сервере, что тоже печалит.</li>
<li>Невозможно вытянуть список пользователей, для которых сохранена история.</li>
</ul>
С другой стороны, вы всегда можете вытаскивать историю, начиная с какой-то даты после начальной синхронизации.<br />
Это вкупе с возможностью постраничной навигации по пользователям, покрывает подавляющее большинство юзкейсов.<br />
Все это, конечно же, решается разными костылями.<br />
Непонятно, как в протоколе это все было упущено.<br />
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0352.html">XEP-0352</a>
<br />
<b>Client State Indication</b><br />
Позволяет клиенту уведомить сервер про то находится ли приложение перед глазами пользователя (foreground).
Также позволяет экономить траффик непередавая некоторые пакеты.<br />
</p><br />


<p><a href="http://xmpp.org/extensions/xep-0363.html">XEP-0363</a>
<br />
<b>HTTP File Upload</b><br />
Позволяет ввести обмен файлами в чат-группах и когда ваши собеседники оффлайн.
</p><br />

<br />
<br />
<br />
<p>
<h3>Автор</h3>
&copy; Dmytro Nikandrov<br />
</p>
			</div>
		</div>
	</body>
</html>